extends ApiApiBeeClient
class_name AuthenticationApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API AuthenticationApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "AuthenticationApi"


# Operation deviceLogin → POST /api/v1/login/device
# Device login
#
# Authenticate or create a device-backed user using a device_id (no password).
func device_login(
	# deviceLoginRequest: DeviceLoginRequest
	# Device login
	deviceLoginRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/login/device"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_consumable_by_server := ['application/json']
	var bzz_found_producible_mime := false
	for bzz_mime in BZZ_PRODUCIBLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_consumable_by_server:
			bzz_headers["Content-Type"] = bzz_mime
			bzz_found_producible_mime = true
			break
	if not bzz_found_producible_mime:
		var error := ApiApiErrorClient.new()
		error.identifier = "device_login.headers.content_type"
		error.message = "That endpoint only accepts %s as content type(s) and none are supported by this client."
		on_failure.call(error)
		return
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null
	bzz_body = deviceLoginRequest

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OauthApiCallback200Response.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func device_login_threaded(
	# deviceLoginRequest: DeviceLoginRequest
	# Device login
	deviceLoginRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "device_login")
	bzz_callable.bind(
		deviceLoginRequest,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation linkDevice → POST /api/v1/me/device
# Link device ID
#
# Links a device_id to the current authenticated user's account.
func link_device(
	# linkDeviceRequest: LinkDeviceRequest
	# Device ID
	linkDeviceRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/me/device"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_consumable_by_server := ['application/json']
	var bzz_found_producible_mime := false
	for bzz_mime in BZZ_PRODUCIBLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_consumable_by_server:
			bzz_headers["Content-Type"] = bzz_mime
			bzz_found_producible_mime = true
			break
	if not bzz_found_producible_mime:
		var error := ApiApiErrorClient.new()
		error.identifier = "link_device.headers.content_type"
		error.message = "That endpoint only accepts %s as content type(s) and none are supported by this client."
		on_failure.call(error)
		return
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null
	bzz_body = linkDeviceRequest

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func link_device_threaded(
	# linkDeviceRequest: LinkDeviceRequest
	# Device ID
	linkDeviceRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "link_device")
	bzz_callable.bind(
		linkDeviceRequest,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation login → POST /api/v1/login
# Login
#
# Authenticate user with email and password
func login(
	# loginRequest: LoginRequest
	# Login credentials
	loginRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/login"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_consumable_by_server := ['application/json']
	var bzz_found_producible_mime := false
	for bzz_mime in BZZ_PRODUCIBLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_consumable_by_server:
			bzz_headers["Content-Type"] = bzz_mime
			bzz_found_producible_mime = true
			break
	if not bzz_found_producible_mime:
		var error := ApiApiErrorClient.new()
		error.identifier = "login.headers.content_type"
		error.message = "That endpoint only accepts %s as content type(s) and none are supported by this client."
		on_failure.call(error)
		return
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null
	bzz_body = loginRequest

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = Login200Response.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func login_threaded(
	# loginRequest: LoginRequest
	# Login credentials
	loginRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "login")
	bzz_callable.bind(
		loginRequest,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation logout → DELETE /api/v1/logout
# Logout
#
# Invalidate user session token
func logout(
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("DELETE")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/logout"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func logout_threaded(
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "logout")
	bzz_callable.bind(
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation oauthApiCallback → POST /api/v1/auth/{provider}/callback
# API callback / code exchange
#
# Accepts an OAuth authorization code via the API and returns access/refresh tokens on success. If a valid JWT is provided in the Authorization header, the provider will be **linked** to the authenticated user instead of logging in. For the Steam provider, the `code` field should contain a server-verifiable Steam credential (for example a Steam auth ticket or Steam identifier) and will be validated via the Steam Web API.
func oauth_api_callback(
	# provider: String = ""   Eg: provider_example
	provider: String,
	# oauthApiCallbackRequest: OauthApiCallbackRequest
	# Code exchange or steam payload
	oauthApiCallbackRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/auth/{provider}/callback".replace("{" + "provider" + "}", _bzz_urlize_path_param(provider))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_consumable_by_server := ['application/json']
	var bzz_found_producible_mime := false
	for bzz_mime in BZZ_PRODUCIBLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_consumable_by_server:
			bzz_headers["Content-Type"] = bzz_mime
			bzz_found_producible_mime = true
			break
	if not bzz_found_producible_mime:
		var error := ApiApiErrorClient.new()
		error.identifier = "oauth_api_callback.headers.content_type"
		error.message = "That endpoint only accepts %s as content type(s) and none are supported by this client."
		on_failure.call(error)
		return
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null
	bzz_body = oauthApiCallbackRequest

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OauthApiCallback200Response.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func oauth_api_callback_threaded(
	# provider: String = ""   Eg: provider_example
	provider: String,
	# oauthApiCallbackRequest: OauthApiCallbackRequest
	# Code exchange or steam payload
	oauthApiCallbackRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "oauth_api_callback")
	bzz_callable.bind(
		provider,
		oauthApiCallbackRequest,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation oauthCallbackApiAppleIos → POST /api/v1/auth/apple/ios/callback
# Apple callback (native iOS)
#
# Exchanges a native iOS Sign in with Apple authorization code using APPLE_IOS_CLIENT_ID.
func oauth_callback_api_apple_ios(
	# oauthCallbackApiAppleIosRequest: OauthCallbackApiAppleIosRequest
	# Apple callback params
	oauthCallbackApiAppleIosRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/auth/apple/ios/callback"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_consumable_by_server := ['application/json']
	var bzz_found_producible_mime := false
	for bzz_mime in BZZ_PRODUCIBLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_consumable_by_server:
			bzz_headers["Content-Type"] = bzz_mime
			bzz_found_producible_mime = true
			break
	if not bzz_found_producible_mime:
		var error := ApiApiErrorClient.new()
		error.identifier = "oauth_callback_api_apple_ios.headers.content_type"
		error.message = "That endpoint only accepts %s as content type(s) and none are supported by this client."
		on_failure.call(error)
		return
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null
	bzz_body = oauthCallbackApiAppleIosRequest

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OauthApiCallback200Response.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func oauth_callback_api_apple_ios_threaded(
	# oauthCallbackApiAppleIosRequest: OauthCallbackApiAppleIosRequest
	# Apple callback params
	oauthCallbackApiAppleIosRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "oauth_callback_api_apple_ios")
	bzz_callable.bind(
		oauthCallbackApiAppleIosRequest,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation oauthGoogleIdToken → POST /api/v1/auth/google/id_token
# Google ID token login (native/mobile)
#
# Verify a Google OpenID Connect id_token (eg. from Android Credential Manager) and return JWT tokens.
func oauth_google_id_token(
	# oauthGoogleIdTokenRequest: OauthGoogleIdTokenRequest
	# Google ID token
	oauthGoogleIdTokenRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/auth/google/id_token"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_consumable_by_server := ['application/json']
	var bzz_found_producible_mime := false
	for bzz_mime in BZZ_PRODUCIBLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_consumable_by_server:
			bzz_headers["Content-Type"] = bzz_mime
			bzz_found_producible_mime = true
			break
	if not bzz_found_producible_mime:
		var error := ApiApiErrorClient.new()
		error.identifier = "oauth_google_id_token.headers.content_type"
		error.message = "That endpoint only accepts %s as content type(s) and none are supported by this client."
		on_failure.call(error)
		return
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null
	bzz_body = oauthGoogleIdTokenRequest

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OauthApiCallback200Response.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func oauth_google_id_token_threaded(
	# oauthGoogleIdTokenRequest: OauthGoogleIdTokenRequest
	# Google ID token
	oauthGoogleIdTokenRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "oauth_google_id_token")
	bzz_callable.bind(
		oauthGoogleIdTokenRequest,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation oauthRequest → GET /api/v1/auth/{provider}
# Initiate API OAuth
#
# Returns OAuth authorization URL for API clients
func oauth_request(
	# provider: String = ""   Eg: discord
	# OAuth provider
	provider: String,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/auth/{provider}".replace("{" + "provider" + "}", _bzz_urlize_path_param(provider))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OauthRequest200Response.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func oauth_request_threaded(
	# provider: String = ""   Eg: discord
	# OAuth provider
	provider: String,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "oauth_request")
	bzz_callable.bind(
		provider,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation oauthSessionStatus → GET /api/v1/auth/session/{session_id}
# Get OAuth session status
#
# Check the status of an OAuth session for API clients
func oauth_session_status(
	# sessionId: String = ""   Eg: sessionId_example
	# Session ID from OAuth request
	sessionId: String,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/auth/session/{session_id}".replace("{" + "session_id" + "}", _bzz_urlize_path_param(sessionId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OAuthSessionStatus.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func oauth_session_status_threaded(
	# sessionId: String = ""   Eg: sessionId_example
	# Session ID from OAuth request
	sessionId: String,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "oauth_session_status")
	bzz_callable.bind(
		sessionId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation refreshToken → POST /api/v1/refresh
# Refresh access token
#
# Exchange a valid refresh token for a new access token
func refresh_token(
	# refreshTokenRequest: RefreshTokenRequest
	# Refresh token
	refreshTokenRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/refresh"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_consumable_by_server := ['application/json']
	var bzz_found_producible_mime := false
	for bzz_mime in BZZ_PRODUCIBLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_consumable_by_server:
			bzz_headers["Content-Type"] = bzz_mime
			bzz_found_producible_mime = true
			break
	if not bzz_found_producible_mime:
		var error := ApiApiErrorClient.new()
		error.identifier = "refresh_token.headers.content_type"
		error.message = "That endpoint only accepts %s as content type(s) and none are supported by this client."
		on_failure.call(error)
		return
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null
	bzz_body = refreshTokenRequest

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RefreshToken200Response.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func refresh_token_threaded(
	# refreshTokenRequest: RefreshTokenRequest
	# Refresh token
	refreshTokenRequest = null,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "refresh_token")
	bzz_callable.bind(
		refreshTokenRequest,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation unlinkDevice → DELETE /api/v1/me/device
# Unlink device ID
#
# Unlinks the device_id from the current authenticated user. Requires at least one OAuth provider or password to remain.
func unlink_device(
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("DELETE")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/me/device"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func unlink_device_threaded(
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "unlink_device")
	bzz_callable.bind(
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation unlinkProvider → DELETE /api/v1/me/providers/{provider}
# Unlink OAuth provider
#
# Unlinks a provider from the current authenticated user.
func unlink_provider(
	# provider: String = ""   Eg: provider_example
	provider: String,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("DELETE")

	# Compute the URL path to the API resource
	var bzz_path := "/api/v1/me/providers/{provider}".replace("{" + "provider" + "}", _bzz_urlize_path_param(provider))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func unlink_provider_threaded(
	# provider: String = ""   Eg: provider_example
	provider: String,
	on_success: Callable = Callable(),  # func(response: ApiApiResponseClient)
	on_failure: Callable = Callable(),  # func(error: ApiApiErrorClient)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "unlink_provider")
	bzz_callable.bind(
		provider,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


